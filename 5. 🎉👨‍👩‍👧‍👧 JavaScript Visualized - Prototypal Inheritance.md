# 🎉👨‍👩‍👧‍👧 자바스크립트 시각화 : 프로토타입 상속

우리가 왜 문자열, 베열, 또는 객체에서 `.length`, `.split()`, `.join()` 등과 같은 빌트인 메소드를 사용할 수 있는지 궁금한 적이 있습니까? 우리는 저 메소드들은 명시하여 정의한적이없는데, 어디서 온 것일까요? 이젠 "아무도 모르는 자바스크립트의 매직🧚🏻‍♂️" 이라고 말하지 마세요, 사실 **prototypal inheritance (프로토타입 상속)**라고 불리기 때문인지, 그것은 꽤 멋지고, 여러분이 알고 있는 것보다 더 자주 사용되는 것입니다.

우리는 종종 같은 타입의 객체를 많이 만들어야합니다. 개를 찾아볼 수 있는 웹사이트가 있다고 가정해봅시다.

모든 강아지에게, 각각의 강아지를 대신할 객체가 필요합니다! 🐕 매번 새로운 객체를 작성하는 것 대신에, 우리는 `new` 키워드를 이용해 강아지 인스터스를 만들 수 있는 **생성자 함수**를 사용할 것입니다.

모든 강아지 인스턴스는 이름, 종류, 색 변수 그리고 울음소리 함수를 가지고 있습니다.

> 생성자 함수과 this에 관한 내용은 [여기를](https://velog.io/@wlsdud2194/어중간히-알면-안되는-JS-개념-1-this) 확인해주세요

// 사진

강아지 생성자 함수가 생겨났을 떄, 우리가 생성한것은 객체뿐만이 아닙니다. 자동적으로 다른 객체도 생성되는데, 이것을 `prototype`이라 부릅니다. 기본적으로, 이것은 생성자 속성을 포함하며, 이 경우 원래 생성자 함수를 참조할 뿐입니다.

// 사진

강아지 생성자 함수의 `prototype` 속성은 non-enumerable 입니다. non-enumerable 이란, 보이지는 않지만 해당 객체 속성은 여전히 존재하며 접근할 수 있는 것을 의미합니다.

그럼 왜 이 속성이 존재할까요? 먼저, 강아지 객체를 생성해봅시다.

// 사진

`dog1`을 콘솔에 출력해보고, 속성을 한번 열어봅시다.

// 사진

우리가 추가한 `name`, `breed`, `color`, 그리고 `bark`를 볼 수 있습니다. 하지만 `__proto__` 속성은 뭘까요?! 이것은 non-enumerable 입니다. 이 속성은 우리가 객체의 속성을 가져올 때, 일반적으로 보이지는 않습니다.
한번 해당 속성을 열어봅시다.

// 사진

`Dogs.prototype` 객체로 보입니다! `__proto__`는 `Dog.prototype` 객체를 참조하고 있고 이것이 **prototypal inheritance (프로토타입 상속)**의 모든 것입니다. 생성자의 각각의 인스턴스는 생성자의 prototype에 접근할 수 있습니다.

// 사진
