# ✨♻️ 자바스크립트 시각화: 이벤트 루프 Event Loop

이벤트 루프는 모든 자바스크립트 개발자들이 어떻게 해서든 처리해야하는 것 중 하나지만 처음에는 이해하기 조금 혼란스러울 수 있습니다. 저는 시각적으로 학습하기 때문에 gif를 통한 시각적인 방법으로 여러분에게 설명할 수 있을 것이라고 생각합니다. (2019년이지만 어째서인지 gif는 여전히 픽셀화 되어있고 흐릿하네요....)

하지만 먼저, 이벤트 루프가 무엇인지 그리고 왜 관리해주어야 하는지 알아보겠습니다.

자바스크립트는 싱글쓰레드라서 한 번에 한가지 일 실행 시킬 수 있습니다. 보통은 큰 문제가 아니지만, 여러분이 하나에 30초가 걸리는 일을 실행시킨다고 상상해보세요... 우리는 30초 동안 기다린 후에야 다른 일을 실행할 수 있습니다. (자바스크립트는 브라우저의 메인 쓰레드를 기본으로 실행되기 때문에 모든 UI가 멈춘다.) 😬 하지만 2019년에 살고 있는 우리는 느리고 응답하지 않는 웹사이트를 원하지 않습니다.

운 좋게도, 브라우저는 우리에게 웹 API와 자바스크립트 엔진이 제공하지 않는 몇 가지 기능을 제공합니다. 브라우저는 DOM API, `setTimeout`, HTTP 요청 등등을 포함하고 있습니다. 그래서 우리가 블록킹 현상을 해결하고 비동기를 할 수 있도록 도와줍니다 🚀

우리가 함수를 호출할 때, 콜 스택이라고 불리는 곳에 추가됩니다. 콜 스택은 브라우저의 특정 부분이 아니라 자바스크립트 엔진의 한 부분입니다. 또한 스택 자료구조로 이루어져 있기 때문에 FILO(First in, Last Out)를 따릅니다. 따라서 함수가 값을 반환할 때, 스택의 맨 위에서 부터 나옵니다 👋

![first-event-loop](./gifs/eventLoop1.gif)

호출된 함수는 `setTimeout` 함수를 반환합니다. `setTimeout`은 메인 쓰레드의 블록킹 없이 작업이 딜레이 될 수 있도록 해주는 웹 API를 제공합니다. 우리가 setTimeout 함수로 전달했던 콜백 함수(화살표 함수), `() =>　{ return ‘Hey’ }` 는 웹 API에 추가됩니다. 추가되는 동안, setTimeout 함수 그리고 호출했던 함수는 스택에서 나오게 되고 둘 다 값을 반환합니다.

![second-event-loop](./gifs/eventLoop2.gif)

웹 API 내부에서, 우리가 두 번째 전달인자로 넘겨주었던 1000ms 동안 타이머가 작동합니다. 콜백은 즉시 콜 스택에 추가되지 않는다. 대신에 큐(queue)라고 불리는 곳으로 넘겨집니다.

![third-event-loop](./gifs/eventLoop3.gif)

이것은 혼란스러운 부분일 수 있다. 1000ms는 콜백함수가 1000ms 뒤에 콜스택(값의 반환)으로 추가되는 것을 의미하는 것이 아니다. 간단하게 1000ms 뒤에 큐에 추가된다는 것을 의미한지만, 이 큐는 함수가 자신의 차례를 기다리는 큐입니다.

이제 우리가 기다리던 부분... 이벤트 루프가 작동할 때입니다. 이벤트 루프는 큐와 콜스택과 연결됩니다! 만약 콜스택이 비어있고 이전에 호출한 모든 함수가 값을 반환하고 스택을 나갔다면, 큐에 있는 첫 번째 콜백함수가 콜스택에 추가됩니다. 이 경우에, 다른 함수가 호출되지 않으며. 이전에 넣었던 콜백함수가 큐에 첫 번째 아이템일 때, 콜스택는 비어있다는 것을 의미합니다.

![fourth-event-loop](./gifs/eventLoop4.gif)

콜백은 콜 스택에 추가되고, 호출된 뒤, 값을 반환하고 콜 스택을 빠져나가게 됩니다.

![fifth-event-loop](./gifs/eventLoop5.gif)

글을 읽는 것은 재밌지만, 실제로 계속 반복해서 실행해봄으로써 여러분은 이것에 익숙해질 수 있을 겁니다. 아래의 코드를 콘솔에 로그를 찍어내면서 확인해보세요.

```javascript
const foo = () => console.log("First");
const bar = () => setTimeout(() => console.log("Second"), 500);
const baz = () => console.log("Third");

bar();
foo();
baz();
```

---

이해가 됐나요? 우리가 브라우저에서 위 코드를 실행했을 때, 무엇이 일어나는지 빠르게 정리해봅시다.

![final-event-loop](./gifs/eventLoopEnd.gif)

1. bar 함수를 호출한다. bar함수는 `setTimeout` 함수를 반환한다.

2. setTimeout 함수의 콜백은 웹 API에 추가된다. setTimeout 함수와 bar 함수는 콜스택에서 나오게 된다.

3. 타이머가 작동하고, 그동안에 foo가 호출되고 로그에 `First`를 찍는다. foo는 반환(undifined)되고, 동시에 baz가 호출된다, 그리고 콜백함수는 큐(queue)에 추가된다.

4. baz에 `Third` 로그가 찍힌다. baz가 반환된 후, 이벤트 루프는 콜스택이 비어있다는 것을 확인한다. 후에 setTimeout의 콜백을 콜스택에 추가한다.

5. `Second`가 로그에 찍힌다.


이 글을 통해 이벤트 루프가 조금이라도 이해되었으면 좋겠습니다만, 아직 혼란스럽더라도 걱정하지 않아도 됩니다. 가장 중요한 것은 구글에 적합한 용어로 효율적으로 검색하여 특정 에러/작동이 어디서 발생했는지 이해하는 것이고 결국에는 올바른 스택 오버플로우 페이지로 가는 것입니다.

> 본 시리즈은 [DEV](https://dev.to/) 에 올라온 [Lydia Hallie](https://github.com/lydiahallie)의 **JavaScript Visualized 시리즈**를 번역한 것입니다.
>
> - 번역에 오류가 있다면 [Pull Request](https://github.com/wlsdud2194/JavaScript-Visualized-Series/pulls)를 올려주세요.
> - origial author link : [Lydia Hallie의 dev.to](https://dev.to/lydiahallie)

